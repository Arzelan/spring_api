<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>4.5.&#160; ResourceLoaderAware 接口</title>
<link rel="stylesheet" href="styles/html.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.0">
<link rel="start" href="index.html" title="Spring Framework 开发参考手册">
<link rel="up" href="ch04.html" title="第&#160;4&#160;章&#160;资源">
<link rel="prev" href="ch04s04.html" title="4.4.&#160;ResourceLoader">
<link rel="next" href="ch04s06.html" title="4.6.&#160;把Resource作为属性来配置">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id460180"></a>4.5.&#160;
			<code class="interfacename">ResourceLoaderAware</code> 接口</h2></div></div></div>
<p>
			<code class="interfacename">ResourceLoaderAware</code>是特殊的标记接口，它希望拥有一个<code class="interfacename">ResourceLoader</code> 引用的对象。
		</p>
<pre class="programlisting">public interface ResourceLoaderAware {
   void setResourceLoader(ResourceLoader resourceLoader);
}</pre>
<p>当实现了 <code class="interfacename">ResourceLoaderAware</code>接口的类部署到application context(比如受Spring管理的bean)中时，它会被application context识别为 <code class="interfacename">ResourceLoaderAware</code>。
接着application context会调用<code class="methodname">setResourceLoader(ResourceLoader)</code>方法，并把自身作为参数传入该方法(记住，所有Spring里的application context都实现了<code class="interfacename">ResourceLoader</code>接口)。
		</p>
<p>既然 <code class="interfacename">ApplicationContext</code> 就是<code class="interfacename">ResourceLoader</code>，那么该bean就可以实现 <code class="interfacename">ApplicationContextAware</code>接口并直接使用所提供的application context来载入资源，但是通常更适合使用特定的满足所有需要的
			<code class="interfacename">ResourceLoader</code>实现。
			这样一来，代码只需要依赖于可以看作辅助接口的资源载入接口，而不用依赖于整个Spring <code class="interfacename">ApplicationContext</code> 接口。
		</p>
</div></body>
</html>
